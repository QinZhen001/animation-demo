<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>svg的path实现的控制音量</title>
  <style>
    * {
      padding: 0;
      margin: 0;
    }

    .dragging {
      cursor: pointer;
    }

    .drag-button {
      cursor: pointer;
    }

    text {
      user-select: none;
    }
  </style>
</head>
<body>
<svg class="volumn-controller" width="580" height="400" xmlns="http://www.w3.org/2000/svg">
  <text class="text"
        fill="#000"
        x="300" y="100"
        font-size="26">Volumn 0
  </text>
  <path class="volumn-path" stroke="#000" d="m100,247c93,-128 284,-129 388,6" opacity="0.5" stroke-width="1"
        fill="#fff"/>
  <circle class="drag-button" r="12" cy="247" cx="100" stroke-width="1" stroke="#000" fill="#fff"/>
  </g>
</svg>


<br><br><br>
https://juejin.im/post/5b263f886fb9a00e63252dbe?utm_source=gold_browser_extension
<br><br>
把circle的cx/cy改成getPointAtLength的x/y坐标，圆圈就会跑到对应的位置去了：
<br>
这里的问题在于这个API传递的length参数是相对于曲线长度的，但是鼠标移动的位置是线性的，没办法直接知道当前鼠标在曲线上距离起始位置多少。
<br><br>
所以需要算一下，在这个场景里面我们可以取鼠标的x坐标在曲线上对应的位置就可以了
<br><br>
到这里就有思路了，可以把这条路径上每隔一个像素长度就算一下它的坐标在哪里，然后存在一个数组里面。由于鼠标移动的时候x坐标是知道的，就可以查一下在这个数组里面相应x坐标的y坐标是多少，就能得到想要的圆心位置了。

</body>
<script>
    let volumnPath = document.querySelector('.volumn-path')
    // 输出path在长度为100的位置的点坐标
    console.log(volumnPath.getPointAtLength(100))
    // 输出当前path的总长度
    console.log(volumnPath.getTotalLength());

    let $volumnController = document.querySelector('.volumn-controller'),
        $volumnPath = $volumnController.querySelector('.volumn-path');


    //得到当前路径的总长度
    let pathTotalLength = $volumnPath.getTotalLength() >> 0;
    let points = []
    //起始位置为长度为0的位置
    let startX = Math.round($volumnPath.getPointAtLength(0).x)
    //记录下每个x对应的path长度
    let volumnDistances = []
    //每隔一个像素点距离就保存一下路径上的点的坐标
    for (let i = 0; i < pathTotalLength; i++) {
        let p = $volumnPath.getPointAtLength(i);
        // 保存的坐标四舍五入 可以平衡误差
        let x = Math.round(p.x) - startX
        points[x] = Math.round(p.y)
        volumnDistances[x] = i
    }

    //    console.log(points)
    //    这里用一个p0ints数组来保存，它的索引index就为x坐标，值为y坐标。
    //    在这个例子里面，总长度为451.5px，得到的points数组长度为388

    //    然后监听鼠标事件，得到x坐标，查询y坐标，动态地改变circle的圆心位置

    let $dragButton = $volumnController.querySelector('.drag-button'),
        // 得到起始位置相对当前视窗的位置，相当于jQuery.fn.offset
        dragButtonPos = $dragButton.getBoundingClientRect()

    let $text = $volumnController.querySelector('.text')


    $volumnPath.addEventListener('click', movePoint)
    $dragButton.addEventListener('mousedown', function (event) {
        document.body.classList.add('dragging')
        document.addEventListener('mousemove', movePoint);

    });
    document.addEventListener('mouseup', function () {
        document.body.classList.remove('dragging')
        document.removeEventListener('mousemove', movePoint);
    });

    function movePoint(event) {
        // 当前鼠标的位置减去圆心起始位置就得到移位偏差，12是半径值，这里先直接写死
        let diffx = event.clientX - Math.round(dragButtonPos.left + 12)
        //需要做个边界判断
        diffx < 0 && (diffx = 0)
        diffx >= points.length && (diffx = points.length - 1)
        $dragButton.setAttribute('cx', diffx + startX)
        // 使用points数组得到y坐标
        $dragButton.setAttribute('cy', points[diffx])

        let volumnValue = Math.round(volumnDistances[diffx] / pathTotalLength * 100)
        $text.textContent = `Volumn ${volumnValue}`
    }


</script>
</html>